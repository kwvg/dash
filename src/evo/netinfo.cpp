// Copyright (c) 2025 The Dash Core developers
// Distributed under the MIT software license, see the accompanying
// file COPYING or http://www.opensource.org/licenses/mit-license.php.

#include <evo/netinfo.h>

#include <coinjoin/client.h>
#include <chainparams.h>
#include <evo/deterministicmns.h>
#include <evo/simplifiedmns.h>
#include <netbase.h>
#include <util/check.h>
#include <util/system.h>

#include <univalue.h>

namespace {
static std::unique_ptr<const CChainParams> g_main_params{nullptr};

const bool IsNodeOnMainnet() { return Params().NetworkIDString() == CBaseChainParams::MAIN; }
const CChainParams& MainParams()
{
    // TODO: use real args here
    if (!g_main_params) g_main_params = CreateChainParams(ArgsManager{}, CBaseChainParams::MAIN);
    return *g_main_params;
}

static const CService empty_service{CService()};
} // anonymous namespace

UniValue ArrFromService(const CService& addr)
{
    UniValue obj(UniValue::VARR);
    obj.push_back(addr.ToStringAddrPort());
    return obj;
}

bool IsServiceDeprecatedRPCEnabled()
{
    const auto args = gArgs.GetArgs("-deprecatedrpc");
    return std::find(args.begin(), args.end(), "service") != args.end();
}

// Compatibility code to populate an array generated by MnNetInfo::GetJson() with Platform
// network information even though we don't store that in MnNetInfo.
UniValue MaybeAddPlatformNetInfo(const CDeterministicMN& dmn, const UniValue& arr)
{
    assert(arr.type() == UniValue::VOBJ);
    if (Assert(dmn.pdmnState)->netInfo->CanStorePlatform()) return arr;
    if (dmn.nType != MnType::Evo) return arr;
    const CService& addr{Assert(dmn.pdmnState)->netInfo->GetPrimary()}; UniValue ret{arr};
    ret.pushKV(PurposeToString(Purpose::PLATFORM_HTTP, /*lower=*/true), ArrFromService(CService(CNetAddr{addr}, dmn.pdmnState->platformHTTPPort)));
    ret.pushKV(PurposeToString(Purpose::PLATFORM_P2P, /*lower=*/true), ArrFromService(CService(CNetAddr{addr}, dmn.pdmnState->platformP2PPort)));
    return ret;
}

// Needed for classes that implement their own ToJson()
namespace {
template <typename T1>
UniValue IMaybeAddPlatformNetInfo(const T1& obj, const MnType& type, const UniValue& arr)
{
    assert(arr.type() == UniValue::VOBJ);
    if (obj.netInfo->CanStorePlatform()) return arr;
    if (type != MnType::Evo) return arr;
    const CService& addr{obj.netInfo->GetPrimary()}; UniValue ret{arr};
    ret.pushKV(PurposeToString(Purpose::PLATFORM_HTTP, /*lower=*/true), ArrFromService(CService(CNetAddr{addr}, obj.platformHTTPPort)));
    if constexpr (!std::is_same<T1, CSimplifiedMNListEntry>::value) /* CSimplifiedMNListEntry doesn't have this field */ {
        ret.pushKV(PurposeToString(Purpose::PLATFORM_P2P, /*lower=*/true), ArrFromService(CService(CNetAddr{addr}, obj.platformP2PPort)));
    }
    return ret;
}
} // anonymous namespace
UniValue MaybeAddPlatformNetInfo(const CDeterministicMNState& obj, const MnType& type, const UniValue& arr) {
    return IMaybeAddPlatformNetInfo(obj, type, arr);
}
UniValue MaybeAddPlatformNetInfo(const CProRegTx& obj, const UniValue& arr) {
    return IMaybeAddPlatformNetInfo(obj, obj.nType, arr);
}
UniValue MaybeAddPlatformNetInfo(const CProUpServTx& obj, const UniValue& arr) {
    return IMaybeAddPlatformNetInfo(obj, obj.nType, arr);
}
UniValue MaybeAddPlatformNetInfo(const CSimplifiedMNListEntry& obj, const MnType& type, const UniValue& arr) {
    return IMaybeAddPlatformNetInfo(obj, type, arr);
}

std::optional<std::reference_wrapper<const CService>> NetInfoEntry::GetAddrPort() const
{
    if (IsTypeBIP155(type)) {
        return data;
    }
    return std::nullopt;
}

// NetInfoEntry is a dumb object that doesn't enforce validation rules, that is the responsibility of
// types that utilize NetInfoEntry (MnNetInfo and others). IsTriviallyValid() is there to check if a
// NetInfoEntry object is properly constructed.
bool NetInfoEntry::IsTriviallyValid() const
{
    // Empty underlying data isn't a valid entry
    if (data == CService() || type == INVALID_TYPE) return false;
    // Type code should be truthful as it decides what underlying type is used when (de)serializing
    if (type != GetBIP155FromService(data)) return false;
    // Underlying data should at least meet surface-level validity checks
    if (!data.IsValid()) return false;
    // Type code should be supported by NetInfoEntry
    return IsTypeBIP155(type);
}

std::string NetInfoEntry::ToString() const
{
    return strprintf("CService(addr=%s, port=%d)", data.ToStringAddr(), data.GetPort());
}

std::string NetInfoEntry::ToStringAddrPort() const
{
    return data.ToStringAddrPort();
}

NetInfoStatus MnNetInfo::ValidateService(const CService& service)
{
    if (!service.IsValid()) {
        return NetInfoStatus::BadInput;
    }
    if (!service.IsIPv4()) {
        return NetInfoStatus::BadInput;
    }
    if (Params().RequireRoutableExternalIP() && !service.IsRoutable()) {
        return NetInfoStatus::BadInput;
    }

    const auto default_port_main = MainParams().GetDefaultPort();
    if (IsNodeOnMainnet() && service.GetPort() != default_port_main) {
        // Must use mainnet port on mainnet
        return NetInfoStatus::BadPort;
    } else if (service.GetPort() == default_port_main) {
        // Using mainnet port prohibited outside of mainnet
        return NetInfoStatus::BadPort;
    }

    return NetInfoStatus::Success;
}

NetInfoStatus MnNetInfo::AddEntry(const Purpose purpose, const std::string& input)
{
    // We only support storing Core P2P addresses, so the max limit for any other
    // purpose is 0 but even if it's a Core P2P address, we only support one entry,
    // so if we have anything stored already, we're full.
    if (purpose != Purpose::CORE_P2P || !IsEmpty()) {
        return NetInfoStatus::MaxLimit;
    }
    if (auto service = Lookup(input, /*portDefault=*/Params().GetDefaultPort(), /*fAllowLookup=*/false); service.has_value()) {
        const auto ret = ValidateService(service.value());
        if (ret == NetInfoStatus::Success) {
            if (service == addr.data) {
                // Not possible since we allow only one value at most
                return NetInfoStatus::Duplicate;
            }
            addr = NetInfoEntry(service.value());
        }
        return ret;
    }
    return NetInfoStatus::BadInput;
}

NetInfoList MnNetInfo::GetEntries() const
{
    NetInfoList ret;
    if (!IsEmpty() && addr.IsTriviallyValid()) {
        ret.push_back(addr);
    }
    // If NetInfoEntry is empty or invalid, we probably want to skip code that expects valid
    // entries to iterate through, so we return a blank set instead.
    return ret;
}

UniValue MnNetInfo::ToJson() const
{
    UniValue ret(UniValue::VOBJ);
    ret.pushKV(PurposeToString(Purpose::CORE_P2P, /*lower=*/true), ArrFromService(addr.data));
    return ret;
}

std::string MnNetInfo::ToString() const
{
    return strprintf("MnNetInfo()\n"
    // Extra padding to account for padding done by the calling function.
                     "    NetInfo(purpose=%s)\n"
                     "      %s\n",
                     PurposeToString(Purpose::CORE_P2P), addr.ToString());
}

NetInfoStatus ExtNetInfo::ProcessCandidate(const Purpose& purpose, const NetInfoEntry& candidate)
{
    assert(candidate.IsTriviallyValid());

    if (const auto& all_entries{GetEntries()};
        std::find_if(all_entries.begin(), all_entries.end(), [candidate](const auto& obj){ return obj.get() == candidate; }) != all_entries.end()) {
        // We don't allow duplicate entries even *across* different lists
        return NetInfoStatus::Duplicate;
    }
    if (auto it{m_data.find(purpose)}; it != m_data.end()) {
        // Existing entries list found, run some more sanity checks
        auto& [_, entries] = *it;
        if (entries.size() > EXTNETINFO_ENTRIES_LIMIT) {
            return NetInfoStatus::MaxLimit;
        }
        entries.emplace(candidate);
        return NetInfoStatus::Success;
    } else {
        // The first entry is subject to additional restrictions, check if it obeys those rules
        if (purpose == Purpose::CORE_P2P || purpose == Purpose::PLATFORM_P2P) {
            if (candidate.GetType() != PRIMARY_ADDR_TYPE) {
                // The first ("primary") entry may only be of the primary type
                return NetInfoStatus::BadInput;
            }
        }
        // First entry for purpose code, create new entries list
        auto [_, status] = m_data.try_emplace(purpose, std::set<NetInfoEntry>({candidate}));
        assert(status); // We did just check to see if our value already existed, try_emplace shouldn't fail
        return NetInfoStatus::Success;
    }
}

NetInfoStatus ExtNetInfo::ValidateService(const CService& service)
{
    if (!service.IsValid()) {
        return NetInfoStatus::BadInput;
    }
    if (Params().RequireRoutableExternalIP() && !service.IsRoutable()) {
        return NetInfoStatus::BadInput;
    }
    if (!IsTypeBIP155(GetBIP155FromService(service))) {
        return NetInfoStatus::BadInput;
    }
    if (IsBadPort(service.GetPort()) || service.GetPort() == 0) {
        return NetInfoStatus::BadPort;
    }

    return NetInfoStatus::Success;
}

NetInfoStatus ExtNetInfo::AddEntry(const Purpose purpose, const std::string& input)
{
    if (!IsValidPurpose(static_cast<uint8_t>(purpose))) {
        // Somebody tried to sneak in a bad value
        return NetInfoStatus::Malformed;
    }

    if (auto service = Lookup(input, /*portDefault=*/Params().GetDefaultPort(), /*fAllowLookup=*/false); service.has_value()) {
        const auto ret = ValidateService(service.value());
        if (ret == NetInfoStatus::Success) {
            return ProcessCandidate(purpose, NetInfoEntry(service.value()));
        }
        return ret; /* ValidateService() failed */
    }
    return NetInfoStatus::BadInput; /* Lookup() failed */
}

// Return all entries. Use in code where we check for duplicates.
NetInfoList ExtNetInfo::GetEntries() const
{
    NetInfoList ret;
    for (const auto& [_, entries] : m_data) {
        ret.insert(ret.end(), entries.begin(), entries.end());
    }
    return ret;
}

const CService& ExtNetInfo::GetPrimary() const
{
    if (const auto& it{m_data.find(Purpose::CORE_P2P)}; it != m_data.end()) {
        const auto& [_, entries] = *it;
        if (!entries.empty()) {
            if (const auto& service{entries.begin()->GetAddrPort()}; service.has_value()) {
                return service.value();
            }
        }
    }
    return empty_service;
}

NetInfoStatus ExtNetInfo::Validate() const
{
    if (m_version == 0 || m_version > NETINFO_FORMAT_VERSION) {
        // Invalid version
        return NetInfoStatus::Malformed;
    }

    for (const auto& [purpose, p_entries] : m_data) {
        if (!IsValidPurpose(static_cast<uint8_t>(purpose))) {
            // Invalid purpose code
            return NetInfoStatus::Malformed;
        }
        if (p_entries.empty()) {
            // Purpose if present in map must have at least one entry
            return NetInfoStatus::Malformed;
        }
        for (const auto& entry : p_entries) {
            if (!entry.IsTriviallyValid()) {
                // Trivially invalid NetInfoEntry, no point checking against consensus rules
                return NetInfoStatus::Malformed;
            }
            if (entry == *p_entries.begin() && entry.GetType() != PRIMARY_ADDR_TYPE) {
                // First entry must be of the primary type
                return NetInfoStatus::Malformed;
            }
            if (const auto& service{entry.GetAddrPort()}; service.has_value()) {
                if (auto ret{ValidateService(*service)}; ret != NetInfoStatus::Success) {
                    // Stores CService underneath but doesn't pass validation rules
                    return ret;
                }
            } else {
                // Doesn't store valid type underneath
                return NetInfoStatus::Malformed;
            }
        }
    }
    return NetInfoStatus::Success;
}

UniValue ExtNetInfo::ToJson() const
{
    UniValue ret(UniValue::VOBJ);
    for (const auto& [purpose, p_entries] : m_data) {
        if (!IsValidPurpose(static_cast<uint8_t>(purpose))) {
            return UniValue(UniValue::VOBJ);
        }
        UniValue arr(UniValue::VARR);
        for (const auto& entry : p_entries) {
            arr.push_back(entry.ToStringAddrPort());
        }
        ret.pushKV(PurposeToString(purpose, /*lower=*/true), arr);
    }
    return ret;
}

std::string ExtNetInfo::ToString() const
{
    std::string ret{"ExtNetInfo()\n"};
    for (const auto& [purpose, p_entries] : m_data) {
        if (!IsValidPurpose(static_cast<uint8_t>(purpose))) {
            return strprintf(
                "ExtNetInfo()\n"
                "    [invalid object]\n"
            );
        }
        ret += strprintf("    NetInfo(purpose=%s)\n", PurposeToString(purpose));
        if (p_entries.empty()) {
            ret += strprintf("      [invalid list]\n");
        } else {
            for (const auto& entry : p_entries) {
                ret += strprintf("      %s\n", entry.ToString());
            }
        }
    }
    return ret;
}

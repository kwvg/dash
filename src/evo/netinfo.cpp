// Copyright (c) 2025 The Dash Core developers
// Distributed under the MIT software license, see the accompanying
// file COPYING or http://www.opensource.org/licenses/mit-license.php.

#include <evo/netinfo.h>

#include <coinjoin/client.h>
#include <chainparams.h>
#include <evo/deterministicmns.h>
#include <evo/simplifiedmns.h>
#include <netbase.h>
#include <util/check.h>
#include <util/system.h>

#include <univalue.h>

namespace {
static std::unique_ptr<const CChainParams> g_main_params{nullptr};

const bool IsNodeOnMainnet() { return Params().NetworkIDString() == CBaseChainParams::MAIN; }
const CChainParams& MainParams()
{
    // TODO: use real args here
    if (!g_main_params) g_main_params = CreateChainParams(ArgsManager{}, CBaseChainParams::MAIN);
    return *g_main_params;
}

bool HasBadTLD(const std::string& str) {
    const std::vector<std::string_view> blocklist{
        ".local",
        ".intranet",
        ".internal",
        ".private",
        ".corp",
        ".home",
        ".lan",
        ".home.arpa"
    };
    for (const auto& tld : blocklist) {
        if (tld.size() > str.size()) continue;
        if (std::equal(tld.rbegin(), tld.rend(), str.rbegin())) return true;
    }
    return false;
}

static constexpr std::string_view SAFE_CHARS_RFC1035{"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789.-"};
} // anonymous namespace

DomainStr::Status DomainStr::ValidateDomain(const std::string& input)
{
    if (input.length() > 253 || input.length() < 4) {
        return DomainStr::Status::BadLen;
    }
    for (char c : input) {
        if (SAFE_CHARS_RFC1035.find(c) == std::string::npos) {
            return DomainStr::Status::BadChar;
        }
    }
    if (input.at(0) == '.' || input.at(input.length() - 1) == '.') {
        return DomainStr::Status::BadCharPos;
    }
    std::vector<std::string> labels{SplitString(input, '.')};
    if (labels.size() < 2) {
        return DomainStr::Status::BadDotless;
    }
    if (HasBadTLD(input)) {
        return DomainStr::Status::BadTLD;
    }
    for (const auto& label : labels) {
        if (label.empty() || label.length() > 63) {
            return DomainStr::Status::BadLabelLen;
        }
        if (label.at(0) == '-' or label.at(label.length() - 1) == '-') {
            return DomainStr::Status::BadLabelCharPos;
        }
    }
    return DomainStr::Status::Success;
}

DomainStr::Status DomainStr::Set(const std::string& input)
{
    const auto ret{ValidateDomain(input)};
    if (ret == DomainStr::Status::Success) {
        data = input;
    }
    return ret;
}

UniValue ArrFromService(CService addr)
{
    UniValue obj(UniValue::VARR);
    obj.push_back(addr.ToStringAddrPort());
    return obj;
}

bool IsServiceDeprecatedRPCEnabled()
{
    const auto args = gArgs.GetArgs("-deprecatedrpc");
    return std::find(args.begin(), args.end(), "service") != args.end();
}

// Compatibility code to populate an array generated by MnNetInfo::GetJson() with Platform
// network information even though we don't store that in MnNetInfo.
UniValue MaybeAddPlatformNetInfo(const CDeterministicMN& dmn, UniValue arr)
{
    assert(arr.type() == UniValue::VARR);
    if (dmn.nType != MnType::Evo) return arr;
    CNetAddr addr{Assert(dmn.pdmnState)->netInfo.GetPrimary()};
    arr.pushKV(ToLower(PurposeToString(Purpose::PLATFORM_HTTP)), ArrFromService(CService(addr, dmn.pdmnState->platformHTTPPort)));
    arr.pushKV(ToLower(PurposeToString(Purpose::PLATFORM_P2P)), ArrFromService(CService(addr, dmn.pdmnState->platformP2PPort)));
    return arr;
}

// Needed for classes that implement their own ToJson()
namespace {
template <typename T1>
UniValue MaybeAddPlatformNetInfo(const T1& obj, MnType type, UniValue arr)
{
    assert(arr.type() == UniValue::VARR);
    if (type != MnType::Evo) return arr;
    CNetAddr addr{obj.netInfo.GetPrimary()};
    arr.pushKV(ToLower(PurposeToString(Purpose::PLATFORM_HTTP)), ArrFromService(CService(addr, obj.platformHTTPPort)));
    if constexpr (!std::is_same<T1, CSimplifiedMNListEntry>::value) /* CSimplifiedMNListEntry doesn't have this field */ {
        arr.pushKV(ToLower(PurposeToString(Purpose::PLATFORM_P2P)), ArrFromService(CService(addr, obj.platformP2PPort)));
    }
    return arr;
}
} // anonymous namespace
UniValue MaybeAddPlatformNetInfo(const CDeterministicMNState& obj, MnType type, UniValue arr) {
    return MaybeAddPlatformNetInfo(obj, type, arr);
}
UniValue MaybeAddPlatformNetInfo(const CProRegTx& obj, UniValue arr) {
    return MaybeAddPlatformNetInfo(obj, obj.nType, arr);
}
UniValue MaybeAddPlatformNetInfo(const CProUpServTx& obj, UniValue arr) {
    return MaybeAddPlatformNetInfo(obj, obj.nType, arr);
}
UniValue MaybeAddPlatformNetInfo(const CSimplifiedMNListEntry& obj, MnType type, UniValue arr) {
    return MaybeAddPlatformNetInfo(obj, type, arr);
}

std::optional<CService> NetInfo::GetAddrPort() const
{
    if (IsTypeBIP155(type)) {
        return CService(addr, port);
    }
    return std::nullopt;
}

std::string NetInfo::ToString() const
{
    return strprintf("%s:%d", addr.ToStringAddr(), port);
}

NetInfoStatus MnNetInfo::ValidateService(const CService& service)
{
    if (!service.IsValid()) {
        return NetInfoStatus::BadInput;
    }
    if (!service.IsIPv4()) {
        return NetInfoStatus::BadInput;
    }
    if (Params().RequireRoutableExternalIP() && !service.IsRoutable()) {
        return NetInfoStatus::BadInput;
    }

    const auto default_port_main = MainParams().GetDefaultPort();
    if (IsNodeOnMainnet() && service.GetPort() != default_port_main) {
        // Must use mainnet port on mainnet
        return NetInfoStatus::BadPort;
    } else if (service.GetPort() == default_port_main) {
        // Using mainnet port prohibited outside of mainnet
        return NetInfoStatus::BadPort;
    }

    return NetInfoStatus::Success;
}

NetInfoStatus MnNetInfo::AddEntry(const Purpose purpose, const std::string input)
{
    // We only support storing Core P2P addresses, so the max limit for any other
    // purpose is 0 but even if it's a Core P2P address, we only support one entry,
    // so if we have anything stored already, we're full.
    if (purpose != Purpose::CORE_P2P || !IsEmpty()) {
        return NetInfoStatus::MaxLimit;
    }
    if (auto service = Lookup(input, /*portDefault=*/Params().GetDefaultPort(), /*fAllowLookup=*/false); service.has_value()) {
        const auto ret = ValidateService(service.value());
        if (ret == NetInfoStatus::Success) {
            if (service == addr) {
                // Not possible since we allow only one value at most
                return NetInfoStatus::Duplicate;
            }
            addr = service.value();
        }
        return ret;
    }
    return NetInfoStatus::BadInput;
}

std::vector<NetInfo> MnNetInfo::GetEntries() const
{
    return IsEmpty() ? std::vector<NetInfo>() : std::vector<NetInfo>({addr});
}

UniValue MnNetInfo::ToJson() const
{
    UniValue ret(UniValue::VOBJ);
    ret.pushKV(ToLower(PurposeToString(Purpose::CORE_P2P)), ArrFromService(addr));
    return ret;
}

std::string MnNetInfo::ToString() const
{
    return strprintf("MnNetInfo()\n"
    // Extra padding to account for padding done by the calling function.
                     "    NetInfo(purpose=%s)\n"
                     "      CService(ip=%s, port=%u)\n",
                     PurposeToString(Purpose::CORE_P2P), addr.ToStringAddr(), addr.GetPort());
}
